


# 성능 개선을 위한 캐싱 및 Redis 활용 로직

### 목표
    - 조회가 오래 걸리는 쿼리에 대한 캐싱을 통해 성능을 개선.
    - Redis를 이용한 로직 이관을 통해 대기열 관리 성능을 개선.
### 현재 문제
    - 콘서트 조회 쿼리가 오래 걸려 사용자 경험이 저하되고 서버 부하가 증가.
    - 대기열 관리에서 실시간으로 변동되는 데이터를 효율적으로 관리할 필요가 있음.
### 개선 방안
#### 콘서트 조회 캐싱
    1. 이유
    - 콘서트 정보는 자주 변하지 않는 데이터.
    - 데이터베이스에 자주 접근하지 않고도 빠르게 조회할 수 있도록 캐싱.
    
    2. 솔루션
    - 콘서트 조회 결과를 Redis에 캐싱.
    - 캐시가 만료되면 데이터베이스에서 데이터를 다시 가져와 캐싱.
    
    3. 캐시설정
    - Redis 캐시 TTL(Time-To-Live)을 24시간으로 설정하여, 캐시된 데이터가 한 시간 동안 유효하도록 함.
#### 대기열 관리
    1. 이유
    - 대기열은 실시간으로 변동되는 데이터이므로 Redis를 활용하여 성능을 개선.
    - Redis의 ZSet을 사용하여 대기열을 효율적으로 관리.
    
    2. 솔루션
    - 각 콘서트별 대기열을 Redis ZSet으로 관리하여 순서대로 관리한다.
    - 추가로 각 토큰마다 value ops에 TTL을 추가하여 대기중인 상태에서 기본 만료되도록한다.
    - ZADD 명령어로 신규 대기열을 추가
    - ZRANK 명령어로 토큰 조회에 내 앞 대기인원을 계산
    - ZRANGE 명령어로 Active 토큰으로 활성화할 목록을 가지고 옴
    - 각 콘서트마다 대기중인 토큰 개수의 비율을 구하고, 최대 활성화 가능 토큰 수를 해당 비율에 맞춰 콘서트별 활성화시킬 토큰수를 계산하고 대기중인 토큰을 활성화시킨다.
    - 활성화 된 토큰은 Set 에 저장하여 관리한다.
    - 추가로 각 토큰마다 value ops에 TTL을 추가하여 활성화 상태에서 일정시간이 지나면 만료되도록한다.
    - value ops에서 사라진 토큰과 Set에 있는 토큰을 비교하여 일정 주기마다 만료된 토큰을 지운다.
### 결론
    - 콘서트 조회는 캐싱을 통해 성능을 개선하고 데이터베이스 부하를 줄임.
    - 대기열 관리는 Redis ZSet을 활용하여 효율적으로 관리하고, TTL을 통해 만료된 항목을 자동으로 제거함으로써 일관성을 유지.
    - 이러한 접근 방식을 통해 시스템 성능을 크게 향상시킬 수 있음.


---
# 동시성 관리 케이스와 락 적용 전략

### 비관적 락 (Pessimistic Locking)
- **장점**:
    - 데이터 접근 시점에 바로 잠금을 걸어서, 다른 사용자의 접근을 막을 수 있어 데이터 정합성을 높일 수 있다.
    - 충돌이 발생할 확률이 낮아 사용자에게 더 예측 가능한 동작을 제공할 수 있다.
- **단점**:
    - 잠금을 걸어 대기하는 동안 성능이 저하될 수 있다. 특히 다수의 사용자가 동시에 접근할 때, 잠금 경합이 발생하여 처리 시간이 길어질 수 있다.
    - 잠금이 발생할 경우 대기 시간이 발생하므로, 사용자 경험에 부정적인 영향을 줄 수 있다.
    - 잠금을 풀지 않고 오랜 시간 사용자가 잠금을 유지하는 경우, 다른 사용자의 접근을 막을 수 있으며, 이는 성능 저하로 이어질 수 있다.
    - 비관적 락은 데드락 상황이 발생할 수 있다. 두 개 이상의 리소스를 기다리는 동시에 잠금을 걸면, 각 사용자가 서로의 잠금을 기다릴 수 있어 데드락 상황이 발생할 가능성이 있다.


### 낙관적 락 (Optimistic Locking)
- **장점**:
    - 락을 사용하지 않고 버전 비교를 통해 업데이트를 시도한다. 따라서 동시성이 높고, 병목 현상이 줄어들 수 있다.
    - 잠금 대기 시간이 없어 사용자 경험이 개선될 수 있다.
    - 버전 확인을 통해 데이터 정합성을 유지한다.
    - 일반적으로 데드락을 발생시키지 않는다.
- **단점**:
    - 같은 데이터를 변경할 경우 충돌이 자주 발생할 수 있어, 재시도 횟수에 따라서 성능 저하로 이어질 수 있다.
    - 충돌로 인한 실패시, 사용자에게 적절한 메시지 및 재시도 옵션을 제공해야하므로 예외처리 및 사용자인터페이스 설계에 주의가 필요하다.


---

### 유저 잔액 충전

- **동시성 발생 원인**:
    - 동일한 사용자가 같은 계정의 잔액을 동시에 따닥 충전하려는 경우 충돌 발생의 가능성이 있다.
- **비관적락**:
    - 동일한 사용자가 동시에 충전을 요청하더라도 다른 사용자와의 경합 상황이 아니기 때문에 비관적락으로 해도 실제 서비스에서는 성능저하가 크게 일어나지 않을 것이라고 생각하여
      비관적락을 선택하였다. 간단한 로직이므로 성능상에서 크게 차이 나지 않았다.
- **낙관적락**:
    - 실제로 유의미한 동시 충전이면 충전을 허용해주어야하는데, 이를 위해 재시도를 해야한다는게 비즈니스 로직에서 불편하게 느껴졌다. 최종적으로 선택안함.



### 좌석 예약(좌석 선점)

- **동시성 발생 원인**:
    - 여러 사용자가 동일한 콘서트 좌석을 예약하려고 할때 충돌 발생의 가능성이 있다.
- **비관적락**:
  ![좌석 예약 비관락 13초.png](document%2F%ED%85%8C%EC%8A%A4%ED%8A%B8%2F%EC%A2%8C%EC%84%9D%20%EC%98%88%EC%95%BD%20%EB%B9%84%EA%B4%80%EB%9D%BD%2013%EC%B4%88.png)
    - 총 소요 시간: 13초
    - 성능상에서 차이를 두기 위해서 테스트 시에 일부러 로직에 슬립을 주었는데, 비관적락이 성능상으로 낙관적락보다 느렸다.
    - 비관적 락은 락이 풀릴 때까지 대기하며, 모든 커넥션이 소모되면 커넥션을 얻기 위해 대기해야한다. 이는 커넥션을 점유하고 대기하는 과정에서 성능 저하를 유발한 것으로 판단된다.
- **낙관적락**:
  ![좌석 예약 낙관락 4초.png](document%2F%ED%85%8C%EC%8A%A4%ED%8A%B8%2F%EC%A2%8C%EC%84%9D%20%EC%98%88%EC%95%BD%20%EB%82%99%EA%B4%80%EB%9D%BD%204%EC%B4%88.png)

    - 총 소요 시간: 4초
    - 하나의 좌석을 두고 여러 명이 경쟁 후 1명의 예약만 성공 후 나머지는 실패해야하니, 재시도 로직을 추가하지 않았다.
    - 재시도 로직이 없어 구현이 간단하였다.
    - 성능상에서 차이를 두기 위해서 테스트 시에 일부러 로직에 슬립을 주었는데, 낙관적락이 성능 상 비관적락보다 빠르다.





